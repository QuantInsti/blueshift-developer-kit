{
    "initialize": {
        "prefix": "def initialize",
        "body": [
            "def initialize(context: AlgoContext):",
            "    ''' This function is called once at the start of the strategy. '''",
            "    $0",
            ""
        ],
        "description": "Creates the initialize function."
    },
    "before_trading_start": {
        "prefix": "def before_trading_start",
        "body": [
            "def before_trading_start(context: AlgoContext, data: DataPortal):",
            "    ''' This function is called once every day. '''",
            "    $0",
            ""
        ],
        "description": "Creates the before_trading_start callback function."
    },
    "handle_data": {
        "prefix": "def handle_data",
        "body": [
            "def handle_data(context: AlgoContext, data: DataPortal):",
            "    ''' This function is called every minute. '''",
            "    $0",
            ""
        ],
        "description": "Creates the handle_data callback function."
    },
    "on_data": {
        "prefix": "def on_data",
        "body": [
            "def on_data(context: AlgoContext, data: DataPortal):",
            "    ''' This function is triggerd on every tick update. '''",
            "    $0",
            ""
        ],
        "description": "Creates the on_data callback function."
    },
    "on_trade": {
        "prefix": "def on_trade",
        "body": [
            "def on_trade(context: AlgoContext, data: DataPortal):",
            "    ''' This function is triggerd on every trade update. '''",
            "    $0",
            ""
        ],
        "description": "Creates the on_trade callback function."
    },
    "on_stoploss": {
        "prefix": "def on_stoploss",
        "body": [
            "def on_stoploss(context: AlgoContext, asset: Asset):",
            "    ''' This function is triggerd on a stoploss hit. '''",
            "    $0",
            ""
        ],
        "description": "Creates the on_stoploss callback function."
    },
    "on_takeprofit": {
        "prefix": "def on_takeprofit",
        "body": [
            "def on_takeprofit(context: AlgoContext, asset: Asset):",
            "    ''' This function is triggerd on a take-profit hit. '''",
            "    $0",
            ""
        ],
        "description": "Creates the on_takeprofit callback function."
    },
    "on_update": {
        "prefix": "def on_update",
        "body": [
            "def on_update(context: AlgoContext, params: dict):",
            "    ''' This function is triggerd on external event. '''",
            "    $0",
            ""
        ],
        "description": "Creates the on_update callback function."
    },
    "template:sma crossover": {
        "prefix": "template:sma crossover",
        "body": [
            "'''",
            "A classic moving average crossover strategy.",
            "",
            "**Logic:**",
            "1. Calculate two moving averages for a single stock: one fast, one slow.",
            "2. When the fast MA crosses above the slow MA, go long (buy).",
            "3. When the fast MA crosses below the slow MA, exit the position (sell).",
            "4. Change the signal function to adapt to other indicator(s).",
            "'''",
            "import pandas as pd",
            "from typing import cast, Any",
            "",
            "from blueshift.types import *",
            "from blueshift.api import symbol, order_target_percent, schedule_function, date_rules,time_rules",
            "from blueshift.api import set_algo_parameters, set_slippage, set_commission",
            "from blueshift.finance import commission, slippage",
            "",
            "class MyAlgoContext(AlgoContext):",
            "    '''Algo non parameter variables. Use only to enfore strong type checking. '''",
            "    def __ini__(self):",
            "        self.assets:list[Asset] = [] # container to store asset universe",
            "        self.params:dict[str, Any] = {} # container to store algo parameters",
            "",
            "def initialize(context:AlgoContext):",
            "    '''",
            "    Called once at the start of the algorithm.",
            "    '''",
            "    # Define our asset instrument",
            "    context = cast(MyAlgoContext, context)",
            "    context.assets = [symbol('RELIANCE'), symbol('ITC')]",
            "",
            "    # Define parameters for our moving averages",
            "    context.params = {",
            "        'fast_ma_window':20,         # 20 min for short window",
            "        'slow_ma_window':50,        # 50 min for short window",
            "        'signal_frequency':5        # check signal every 5 min",
            "    }",
            "    # call the API method set_algo_parameters to accept parameters passed externally",
            "    set_algo_parameters()",
            "",
            "    # set slippage and trading costs to 0",
            "    set_slippage(slippage.NoSlippage())",
            "    set_commission(commission.NoCommission())",
            "",
            "    # Schedule a function to run our logic daily, 30 minutes after market open.",
            "    schedule_function(",
            "        rebalance,",
            "        date_rules.everyday(),",
            "        time_rules.market_open(minutes=context.params['signal_frequency'])",
            "    )",
            "",
            "def rebalance(context:AlgoContext, data:DataPortal):",
            "    '''",
            "    This function is called by the scheduler and contains the core trading template.",
            "    '''",
            "    # Get historical price data to calculate moving averages.",
            "    # `history` returns a pandas DataFrame.",
            "    context = cast(MyAlgoContext, context)",
            "    price_history = data.history(context.assets, 'close', ",
            "                                 context.params['slow_ma_window'] + 5, # Get a bit of extra data",
            "                                 '1m'",
            "                                 )",
            "",
            "    # If we don't have enough data yet, do nothing.",
            "    price_history = price_history.dropna()",
            "    if len(price_history) < context.params['slow_ma_window']:",
            "        return",
            "",
            "    # equal weight positions with full capital invested",
            "    weight = 1.0/len(context.assets)",
            "",
            "    # --- Trading Logic --- ",
            "    for asset in context.assets:",
            "        signal = signal_function(context, price_history[asset]) # type: ignore",
            "",
            "        if signal==1:",
            "            # Go long the target weight",
            "            order_target_percent(asset, weight)",
            "        else:",
            "            # Go short the target weight",
            "            order_target_percent(asset, -weight)",
            "",
            "",
            "def signal_function(context:AlgoContext, px:pd.Series):",
            "    ''' core logic of the signal calculation. Change it to implement different indicators/signals. '''",
            "    # --- signal Logic --- ",
            "    # Calculate the fast and slow moving averages",
            "    context = cast(MyAlgoContext, context)",
            "    fast_ma = px.rolling(window=context.params['fast_ma_window']).mean()",
            "    slow_ma = px.rolling(window=context.params['slow_ma_window']).mean()",
            "",
            "    # Get the most recent values for the moving averages",
            "    latest_fast_ma = fast_ma.iloc[-1]",
            "    latest_slow_ma = slow_ma.iloc[-1]",
            "",
            "    # return long signal if fast > slow, else short signal",
            "    if latest_fast_ma > latest_slow_ma:",
            "        # Crossover BUY signal: fast MA crosses above slow MA",
            "        return 1",
            "    else:",
            "        # Crossover SELL signal: fast MA crosses below slow MA",
            "        return -1",
            "",
            ""
        ],
        "description": "A classic moving average crossover strategy."
    },
    "template:intraday options": {
        "prefix": "template:intraday options",
        "body": [
            "'''",
            "An intraday short straddle strategy with stoploss and take-profits",
            "",
            "**Logic:**",
            "1. Sells a straddle (a call and a put at the ATM strike) in the morning at 09:30 AM",
            "2. Set stoploss and take-profit targets at 40% of premiums.",
            "3. If we hit stoploss or take-profit on one leg, the other continues",
            "3. Square-off everything in the afternoon at 15:00 PM",
            "'''",
            "from typing import Any, cast",
            "from blueshift.types import *",
            "from blueshift.api import symbol, order, square_off, terminate",
            "from blueshift.api import set_stoploss, set_takeprofit, get_datetime",
            "from blueshift.api import schedule_function, date_rules, time_rules",
            "from blueshift.api import set_slippage, create_order, set_commission, schedule_soon",
            "from blueshift.finance.slippage import NoSlippage",
            "from blueshift.finance.commission import NoCommission",
            "",
            "class MyAlgoContext(AlgoContext):",
            "    params:dict[str,Any] = {}",
            "",
            "def initialize(context: AlgoContext):",
            "    ''' This function is called once at the start of the strategy. '''",
            "    context = cast(MyAlgoContext, context)",
            "    context.params = {",
            "            'lots':1,",
            "            'stoploss':0.4,",
            "            'takeprofit':0.4,",
            "            'start':'09:30',",
            "            'end':'15:00',",
            "            }",
            "    ",
            "    set_slippage(NoSlippage(max_volume=0))",
            "    set_commission(NoCommission())",
            "",
            "    start = context.params['start']",
            "    end = context.params['end']",
            "    schedule_function(enter, date_rules.everyday(), time_rules.at(start))",
            "    schedule_function(close_out, date_rules.everyday(), time_rules.at(end))",
            "",
            "def enter(context:AlgoContext, data:DataPortal):",
            "    ''' the entry point for the strategy. '''",
            "    context = cast(MyAlgoContext, context)",
            "    dt = get_datetime()",
            "    # options has format as TICKER{Exp}{CE|PE}{STRIKE}, where Exp can be W0, or W1 for ",
            "    # week 1, week 2 etc. For monthly expiries, it I or II etc for current and next month.",
            "    # strike can be offset from ATM (e.g. +200 means 200 points from ATM).",
            "    opts = [",
            "        symbol('NIFTY-W0CE+0', dt=dt, use_spot=True),",
            "        symbol('NIFTY-W0PE+0', dt=dt, use_spot=True),",
            "    ]",
            "    f = lambda context, data:place_entry_orders(opts, context, data)",
            "",
            "    # schedule the function to run as soon as possible",
            "    schedule_soon(f)",
            "",
            "def place_entry_orders(opts:list[Asset], context:AlgoContext, data:DataPortal):",
            "    context = cast(MyAlgoContext, context)",
            "    lots = int(context.params['lots'])",
            "",
            "    for asset in opts:",
            "        qty = lots*asset.mult",
            "        # pre-create the order object",
            "        o = create_order(asset, -qty, validity='ioc')",
            "        # place orders with automatic retries",
            "        oid = order(o, None, max_retries=5)",
            "        if not oid:",
            "            handle_order_failure(context, asset)",
            "        else:",
            "            sl = float(context.params['stoploss'])",
            "            tp = float(context.params['takeprofit'])",
            "            set_stoploss(asset, method='percent', target=sl)",
            "            set_takeprofit(asset, method='percent', target=tp)",
            "",
            "def close_out(context:AlgoContext, data:DataPortal):",
            "    # square off all positions and cancel any open orders",
            "    square_off()",
            "",
            "def handle_order_failure(context:AlgoContext, asset:Asset):",
            "    # basic error handling, gracefully exit on error",
            "    msg = f'failed to place order for asset {asset}'",
            "    terminate(msg)",
            "",
            ""
        ],
        "description": "An intraday short straddle strategy with stoploss and take-profits"
    },
    "template:large universe (pipeline)": {
        "prefix": "template:large universe (pipeline)",
        "body": [
            "'''",
            "A long-only time-series momentum strategy.",
            "",
            "**Logic:**",
            "1. Filter the universe based on liquidity and low beta ",
            "2. Pick the stocks with top returns in recent months and go long",
            "3. Go long with the chosen stocks, exiting anything else in the portfolio",
            "4. Rebalance with the above logic every month",
            "'''",
            "from blueshift.types import AlgoContext, DataPortal",
            "from blueshift.library.pipelines import asset_beta",
            "from blueshift.pipeline import Pipeline",
            "",
            "from blueshift.pipeline.factors.statistical import vectorized_beta",
            "from blueshift.pipeline import CustomFactor, CustomFilter",
            "from blueshift.pipeline.data import EquityPricing",
            "from blueshift.finance.slippage import NoSlippage",
            "from blueshift.finance.commission import NoCommission",
            "",
            "import talib as ta",
            "import numpy as np",
            "import warnings",
            "",
            "from blueshift.errors import NoFurtherDataError",
            "from blueshift.api import order_target_percent, schedule_function, log_info",
            "from blueshift.api import symbol, date_rules, time_rules, get_datetime",
            "from blueshift.api import attach_pipeline, pipeline_output",
            "from blueshift.api import set_commission, set_slippage",
            "",
            "def average_volume_filter(lookback, amount, context=None):",
            "    ''' An example of custom filter wrapped in function. We use the closure to handle extra parameters.'''",
            "    class AvgDailyDollarVolumeTraded(CustomFilter):",
            "        inputs = [EquityPricing.close, EquityPricing.volume]",
            "        def compute(self,today,assets,out,close,volume): # type: ignore[override]",
            "            with warnings.catch_warnings():",
            "                warnings.simplefilter('ignore', category=RuntimeWarning)",
            "                dollar_volume = np.nanmean(close * volume, axis=0)",
            "            high_volume = dollar_volume > amount",
            "            out[:] = high_volume",
            "    ",
            "    return AvgDailyDollarVolumeTraded(window_length = lookback) # type: ignore[override]",
            "",
            "class ROCFactor(CustomFactor):",
            "    ''' An example of custom factor. We specify the window length while instantiating. '''",
            "    inputs = [EquityPricing.close]",
            "    def compute(self,today,assets,out,close): # type: ignore[override]",
            "        out[:] = np.apply_along_axis(lambda col:ta.ROC(col, 63)[-1], axis=0, arr=close) # type: ignore[type]",
            "",
            "def initialize(context:AlgoContext):",
            "    # set 0 costs",
            "    set_slippage(NoSlippage(max_volume=0))",
            "    set_commission(NoCommission())",
            "    # The context variables can be accessed by other methods",
            "    context.params = {'lookback':3, # months, multiply by 21 for business days.",
            "                      'size':5, # max number of stocks in positions",
            "                      'min_volume':1E7, # 10 million average traded volume threshold",
            "                      'cash':0.2, # cash holding percentage",
            "                      }",
            "    ",
            "    # Call rebalance function on the first trading day of each month",
            "    schedule_function(run_strategy, date_rules.month_start(), ",
            "            time_rules.market_close(minutes=30))",
            "",
            "    # Set up the pipe-lines for strategies",
            "    attach_pipeline(make_screener(context), name='my_screener')",
            "",
            "def make_screener(context:AlgoContext):",
            "    ''' an user defined function where we create the pipeline. '''",
            "    pipe = Pipeline()",
            "",
            "    # get the strategy parameters",
            "    lookback = context.params['lookback']*21",
            "    v = context.params['min_volume']",
            "",
            "    # Set the volume filter using a custom filter with parameter passing",
            "    volume_filter = average_volume_filter(lookback, v)",
            "    # add a beta filter, using a built-in factors",
            "    market = symbol('NIFTY')",
            "    beta = asset_beta(market, 60, context)",
            "    ",
            "    # compute past returns - using a custom factor directly",
            "    roc_factor = ROCFactor(window_length=lookback+5) # type: ignore[override]",
            "    ",
            "    pipe.add(roc_factor,'roc')",
            "    pipe.add(beta,'beta')",
            "    ",
            "    # comparing factors with numbers returns filters",
            "    # we can also use math operators like '+', '-', '*' and '/' to combine factors or a factor and a number",
            "    roc_filter = roc_factor > 0 # positive momentum only",
            "    beta_filter = (beta > -0.5) & (beta < 0.5) # select a low beta filter",
            "    ",
            "    # add the filtering",
            "    pipe.set_screen(roc_filter & volume_filter & beta_filter) # combine filters with '&' or '|' operator",
            "",
            "    return pipe",
            "",
            "def screener(context:AlgoContext, data:DataPortal):",
            "    # get the pipeline output and select the top N",
            "    try:",
            "        pipeline_results = pipeline_output('my_screener')",
            "    except NoFurtherDataError:",
            "        log_info('no pipeline for {}'.format(get_datetime()))",
            "        return []",
            "",
            "    pipeline_results = pipeline_results.dropna() # remove NAs",
            "    selected = pipeline_results.sort_values(",
            "        'roc')[-(context.params['size']):] # pick up best N stocks",
            "    ",
            "    # return the asset list, note the pipeline result dataframe has ",
            "    # assets (that survived the filters) as index and the computed ",
            "    # factors as the columns",
            "    return selected.index.tolist()",
            "",
            "def run_strategy(context:AlgoContext, data:DataPortal):",
            "    ''' scheduled to run on first business day of evevry month. '''",
            "    # get screened assets to buy",
            "    assets = screener(context, data)",
            "    current_holdings = context.portfolio.positions.keys() # current holdings",
            "",
            "    exits = set(current_holdings) - set(assets) # assets to sell",
            "    for asset in exits:",
            "        # exit the exiting assets",
            "        order_target_percent(asset, 0)",
            "",
            "    if assets:",
            "        # rebalance the new list with equal weights",
            "        sizing = (1-context.params['cash'])/len(assets)",
            "        for asset in assets:",
            "            order_target_percent(asset, sizing)",
            ""
        ],
        "description": "A pipeline strategy that filters a large universe of stocks and trades the top performers."
    }
}
    